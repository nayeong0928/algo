# K번째 수

## 문제 분석

입력값 N의 범위가 1 ~ 5,000,000 이므로 빠르게 정렬을 하기 위해 퀵소트를 선택했다.  
내가 기존에 알던 퀵소트는 중간값을 pivot으로 삼아 왼쪽은 pivot보다 작은 값이 오고 오른쪽은 pivot보다 큰 값이 오도록 구현하는 알고리즘이었다.
그렇지만 pivot을 중간값으로 삼는 건 임의의 선택이고 pivot이 엄밀히 정렬했을 때 중간값이라고는 할 수 없다. 
pivot보다 큰/작은 값이 배열의 절반 이상일 수도 있으니 말이다. pivot을 임의로 선택하더라도, 해당 pivot의 자리를 알려주는 Quick Selection 알고리즘을 알게 되었다.  
해당 알고리즘의 경우, pivot의 자리와 K값을 비교해서 배열을 부분 탐색하는 것이 가능하다. 이것까지 썼는데도 틀렸지만... 일단 올려본다.


## 구현 (시간초과)

1. partition(): pivot이 어느 인덱스에 위치하는지 알려주는 메소드
2. sort(): partition()을 호출해 pivot의 자리를 알아내고 pivot의 자리와 K값을 비교해서 분할된 범위를 정렬한다.

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Baek11004 {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        sort(arr, 0, N - 1, K - 1);
        System.out.println(arr[K - 1]);
    }

    private static void sort(int[] arr, int start, int end, int K) {

        if (start > end)
            return;

        int pivot = partition(arr, start, end);

        if (pivot == K) {
            return;
        }

        if (K < pivot) {
            sort(arr, start, pivot - 1, K);
        } else {
            sort(arr, pivot + 1, end, K);
        }

    }

    private static int partition(int[] arr, int start, int end) {

        int low = start;
        int high = end;
        int middle = (start + end) / 2;
        int pivot = arr[middle];
        swap(arr, start, middle);

        while (low < high) {
            while (arr[high] > pivot) {
                high--;
            }

            while (low < high && arr[low] <= pivot) {
                low++;
            }

            swap(arr, low, high);
        }
        arr[start] = arr[low];
        arr[low] = pivot;

        return low;
    }

    private static void swap(int[] arr, int i, int j) {
        if (i == j) {
            return;
        }

        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

}


```
