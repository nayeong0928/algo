# 병합정렬

입력을 반으로 나눠서 각각을 정렬하고, 다시 병합하는 정렬

- 최악 시간복잡도: O(n log n)
- 평균 시간복잡도: O(n log n)
- 최선 시간복잡도: O(n log n)

## 구현

### mergeSort(Comparable[] list)
list를 받아서 first와 second로 나누고 merged()를 호출하여 병합정렬한다.  
재귀적으로 호출하면서 나눠진 배열의 길이가 1이 될 때까지 반복한다.  
길이가 1이 되면 그대로 리턴한다.

```java

    private static Comparable[] mergeSort(Comparable[] list) {

        if (list.length <= 1) {
            return list;
        }

        Integer[] first = new Integer[list.length / 2];
        Integer[] second = new Integer[list.length - first.length];

        System.arraycopy(list, 0, first, 0, first.length);
        System.arraycopy(list, first.length, second, 0, second.length);

        mergeSort(first);
        mergeSort(second);

        merged(first, second, list);

        return list;
    }

```

### merged(Comparable[] first, Comparable[] second, Comparable[] result)
각각 정렬된 first, second를 result에 병합정렬한다.  

- 변수
  - firstIndex: first의 현재 위치(인덱스)
  - secondIndex: second의 현재 위치(인덱스)
  - merged: result의 현재 위치(인덱스)

- 동작
  1. first의 firstIndex 위치에 있는 값과 second의 secondIndex 위치에 있는 값을 비교
  2. 둘 중 더 작은 값을 result에 넣음
  3. result에 넣은 배열 인덱스, merged 배열 인덱스를 증가  
  
```java

    private static void merged(Comparable[] first, Comparable[] second, Comparable[] result) {

        int firstIndex = 0;
        int secondIndex = 0;
        int merged = 0;

        while (firstIndex < first.length && secondIndex < second.length) {

            if (first[firstIndex].compareTo(second[secondIndex]) < 0) {
                result[merged] = first[firstIndex];
                firstIndex++;
            } else {
                result[merged] = second[secondIndex];
                secondIndex++;
            }
            merged++;

        }

        System.arraycopy(first, firstIndex, result, merged, first.length - firstIndex);
        System.arraycopy(second, secondIndex, result, merged, second.length - secondIndex);

    }

```
