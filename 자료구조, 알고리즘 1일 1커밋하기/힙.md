# 힙

완전이진트리이면서, 부모 노드가 자식 노드들보다 큰 값(우선순위)를 가지는 자료구조

- 삽입 시간복잡도: O(log n)
- 삭제 시간복잡도: O(log n)

## 구현

### 삽입

1. 힙 배열의 가장 마지막 자리에 새로운 원소를 추가: insert()
2. 부모 원소와 값을 비교, 부모보다 큰 값이면 부모와 자리를 바꾸는 방식으로 거슬러 올라간다 : percateUp()
3. 부모가 자식보다 큰 자리가 새 원소의 자리이다.

```java


    public void insert(E newItem) throws PQException {
        if (num < heap.length) {
            heap[num] = newItem;
            percolateUp(num);
            num++;
        } else
            throw new PQException("저장공간이 모두 찼습니다.");
    }

    private void percolateUp(int i) {
        int parent = (i - 1) / 2;

        if (parent >= 0 && heap[parent].compareTo(heap[i]) < 0) {
            E tmp = heap[parent];
            heap[parent] = heap[i];
            heap[i] = tmp;
            percolateUp(parent);
        }
    }

```

### 삭제

1. 루트 원소의 값을 리턴, 힙의 가장 마지막 원소를 루트의 자리에 넣는다: deleteMax()
2. 자식 원소와 값을 비교, 자식보다 더 작은 경우 자식과 자리를 바꾸는 방식으로 내려간다: percateDown()
3. 자식이 자신보다 작은 자리 혹은 자식이 없는 자리가 새 원소의 자리이다

```java


    public E deleteMax() throws Exception {

        if (!isEmpty()) {
            E result = heap[0];
            heap[0] = heap[num - 1];
            num--;
            percolateDown(0);
            return result;
        } else
            throw new PQException("heap이 비었습니다");
    }

    private void percolateDown(int i) {

        int child = (heap[i * 2 + 1].compareTo(heap[i * 2 + 2]) < 0) ? (i * 2 + 2) : (i * 2 + 1);

        if (heap[i].compareTo(heap[child]) < 0) {
            E tmp = heap[child];
            heap[child] = heap[i];
            heap[i] = tmp;
            percolateDown(child);
        }

    }

```

## 검증

```java

public class App {
    public static void main(String[] args) throws Exception {

        try {
            Heap<Integer> heap = new Heap<>(Integer.class, 5);
            heap.insert(100);
            heap.insert(200);
            heap.insert(300);
            heap.insert(400);
            heap.insert(500);

            System.out.println("힙의 최대값: " + heap.max());
            System.out.println("삭제: " + heap.deleteMax());
            System.out.println("힙의 최대값: " + heap.max());

            heap.insert(600);
            heap.insert(700);

        } catch (PQException e) {
            System.out.println("PQ Exception: " + e.getMessage());
        }
    }
}

```
### 결과
```bash
힙의 최대값: 500
삭제: 500
힙의 최대값: 400
PQ Exception: 저장공간이 모두 찼습니다.
```

## 힙 전체 코드

### 관련 클래스

```java

public interface PQInterface<E> {
    public void insert(E newItem) throws Exception;

    public E deleteMax() throws Exception;

    public E max() throws Exception;

    public boolean isEmpty();

    public void clear();
}

```

```java

public class PQException extends Exception {
    public PQException(String msg) {
        super(msg);
    }
}

```

### Heap

```java

import java.lang.reflect.Array;

public class Heap<E extends Comparable<E>> implements PQInterface<E> {

    private E[] heap;
    private int num;

    public Heap(Class clazz, int size) {
        heap = (E[]) Array.newInstance(clazz, size);
        num = 0;
    }

    @Override
    public void insert(E newItem) throws PQException {
        if (num < heap.length) {
            heap[num] = newItem;
            percolateUp(num);
            num++;
        } else
            throw new PQException("저장공간이 모두 찼습니다.");
    }

    private void percolateUp(int i) {
        int parent = (i - 1) / 2;

        if (parent >= 0 && heap[parent].compareTo(heap[i]) < 0) {
            E tmp = heap[parent];
            heap[parent] = heap[i];
            heap[i] = tmp;
            percolateUp(parent);
        }
    }

    @Override
    public E deleteMax() throws Exception {

        if (!isEmpty()) {
            E result = heap[0];
            heap[0] = heap[num - 1];
            num--;
            percolateDown(0);
            return result;
        } else
            throw new PQException("heap이 비었습니다");
    }

    private void percolateDown(int i) {

        int child = (heap[i * 2 + 1].compareTo(heap[i * 2 + 2]) < 0) ? (i * 2 + 2) : (i * 2 + 1);

        if (heap[i].compareTo(heap[child]) < 0) {
            E tmp = heap[child];
            heap[child] = heap[i];
            heap[i] = tmp;
            percolateDown(child);
        }

    }

    @Override
    public E max() throws Exception {
        if (!isEmpty()) {
            return heap[0];
        } else
            throw new PQException("heap이 비었습니다.");
    }

    @Override
    public boolean isEmpty() {
        return num == 0;
    }

    @Override
    public void clear() {
        heap = (E[]) new Object[heap.length];
        num = 0;
    }

}

```

