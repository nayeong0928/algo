# Maximum Depth of Binary Tree

## 문제 분석

- 트리의 노드 개수는 0 ~ 10000 개까지 가능 -> 아예 텅 빈 트리, root노드의 자식이 없는 경우 체크해야 함
- 노드의 값은 -100 ~ 100 까지 가능 -> int 사용

## 구현

- BFS로 풀이: 어차피 가장 긴 높이를 체크하기 위해서는 모든 경로를 확인해서 가장 긴 노드를 찾아야 하니 같은 경로를 두번 방문하는 경우는 없도록 하기 위해
- 큐 2개 사용: 방문할 노드들을 넣어주는 큐, 방문할 노드들의 높이 저장하는 큐

### 로직
1. 노드 방문: 방문용 큐, 높이용 큐 둘 다 poll()
2. 이 때 방문한 노드를 result 변수에 백업
3. 노드의 자식들을 방문용 큐에 넣어줌
4. 자식들의 높이(현재노드+1)도 높이용 큐에 넣어줌
5. 큐가 빌 때까지 방문
6. result 리턴

```java

public int maxDepth(TreeNode root) {

        if(root==null) return 0;

        Queue<TreeNode> queue=new LinkedList<>();
        Queue<Integer> height=new LinkedList<>();

        queue.add(root);
        height.add(1);

        int result=1;

        while(!queue.isEmpty()){
            TreeNode node=queue.poll(); 
            result=height.poll(); 

            if(node.left==null && node.right==null) {
                continue;
            }

            if(node.left!=null){
                queue.add(node.left); 
                height.add(result+1); 
            }
            
            if (node.right!=null){
                queue.add(node.right);
                height.add(result+1);
            }
            
        }

        return result;
        
    }

```

