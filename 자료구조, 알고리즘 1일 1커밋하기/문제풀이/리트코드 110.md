# Balanced Binary Tree

## 문제 분석

- 노드 0 ~ 5000개
- 노드값 int 범위 안
- 트리 null인 경우도 고려 필요

## 구현

- 균형 이진트리: 서브트리의 높이차가 1 이하인 이진트리
- 서브 트리 중 균형 이진트리가 아닌 트리가 포함되어 있다면 추가 연산 필요 없이 false 리턴  
 (서브트리가 하나만 balance 트리가 아니어도 balance트리가 아니기 때문)
- 후위순회 방식으로 left, right의 높이를 구하고 나서 1을 더해주면 해당 노드의 높이를 구할 수 있음
- 시간복잡도: O(N) => 모든 노드를 방문하는 식으로 높이를 구하기 때문 

### Sub 클래스

- 서브트리에 대한 정보를 담은 객체
- 서브트리를 방문했을 때 필요한 정보: 높이, balance 여부

```java

    private static class Sub{
        int height;
        boolean balanced;

        public Sub(int height, boolean balanced){
            this.height=height;
            this.balanced=balanced;
        }
    }

```

### visit(TreeNode tree)

- 후위순회 방식
- 자신의 정보를 담은 Sub 리턴
- 노드가 null이라면 높이 -1에 균형트리로 리턴
  - 없는 노드를 방문했기 때문에 

``` java

    public static Sub visit(TreeNode tree){

        if(tree==null) return new Sub(-1, true);

        // 왼쪽방문 
        Sub tleft=visit(tree.left);
        if(!tleft.balanced) return tleft;

        // 오른쪽방문
        Sub tright=visit(tree.right);
        if(!tright.balanced) return tright;

        // 자기자신
        int height=Math.max(tleft.height, tright.height)+1;
        boolean balanced=false;

        if(Math.abs(tleft.height-tright.height)<=1) {
            balanced=true;
        }
        
        return new Sub(height, balanced);
    }

```

### 시작 함수

``` java

  public boolean isBalanced(TreeNode root) {
        Sub result=visit(root);
        return result.balanced;
    }

```

