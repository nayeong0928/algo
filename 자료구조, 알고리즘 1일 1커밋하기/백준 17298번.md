# 오큰수

## 문제 분석

수열의 크기가 최대 1,000,000 이기 때문에 i번째의 오큰수를 구하기 위해 i ~ N번째의 수열을 모두 체크하면 시간복잡도가 N^2이 되어 시간초과가 된다.  
또한 i번째 값의 오큰수는 i+1 ~ N번째 수 중에서 가장 왼쪽에 있는 값이다. 따라서 i번째 값의 오큰수를 찾고 나면 그 후로 수열을 순회할 필요가 없다.

## 풀이

- 수열을 인덱스 0~N까지 순회한다.
- 아직 오큰수를 찾지 못한 인덱스를 stack에 넣어둔다.
- 수열을 순회할 때마다 현재값이 오큰수인 수가 stack에 있는지 체크한다.
- 순회가 끝나도록 stack에 남아있는(=오큰수를 찾지 못한 수) 경우는 -1로 표시한다.

``` java

import java.util.Scanner;
import java.util.Stack;

public class Baek17298 {
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] arr = new int[N];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println(oken(arr));
    }

    private static String oken(int[] arr) {
        int[] result = new int[arr.length];
        Stack<Integer> stack = new Stack<>();

        // 수열 순회
        for (int i = 0; i < arr.length; i++) {
            int now = arr[i];

            if (stack.isEmpty() || arr[stack.peek()] >= now) {
                stack.push(i);
            } else {
                // 오큰수 체크
                while (!stack.isEmpty() && arr[stack.peek()] < now) {
                    result[stack.pop()] = now;
                }
                stack.push(i);
            }
        }

        // 오큰수를 갖지 못한 경우 체크
        while (!stack.isEmpty()) {
            result[stack.pop()] = -1;
        }

        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < result.length; i++) {
            sb.append(result[i] + " ");
        }

        return sb.toString();
    }
}

```

