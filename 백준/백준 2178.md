# 미로 탐색

## 문제 분석

- 이동 가능한 경우
  - 인접한 위치 (대각선 안 됨)
  - 미로값이 1인 경우
- N, M 은 2~100까지 올 수 있다: 최악의 경우 모두 방문하더라도 10000번 방문
- 칸 수에는 시작/도착 칸까지 포함

## 구현

- 최단거리를 구하는 것이기 때문에 BFS 사용
- queue: 방문한 칸, 이 칸에서 이동할 수 있는 칸들을 계산하기 위함
- visited: 방문처리

```java

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class sol2178 {

    // 예제 계산용
    // public static void main(String[] args) {

    // int ans1 = solve(4, 6, new int[][] {
    // { 1, 0, 1, 1, 1, 1 },
    // { 1, 0, 1, 0, 1, 0 },
    // { 1, 0, 1, 0, 1, 1 },
    // { 1, 1, 1, 0, 1, 1 } });

    // System.out.println(ans1);

    // int ans2 = solve(4, 6, new int[][] {
    // { 1, 1, 0, 1, 1, 0 },
    // { 1, 1, 0, 1, 1, 0 },
    // { 1, 1, 1, 1, 1, 1 },
    // { 1, 1, 1, 1, 0, 1 } });

    // System.out.println(ans2);

    // int ans3 = solve(2, 25, new int[][] {
    // { 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1
    // },
    // { 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1 }
    // });
    // System.out.println(ans3);

    // int ans4 = solve(7, 7, new int[][] {
    // { 1, 0, 1, 1, 1, 1, 1 },
    // { 1, 1, 1, 0, 0, 0, 1 },
    // { 1, 0, 0, 0, 0, 0, 1 },
    // { 1, 0, 0, 0, 0, 0, 1 },
    // { 1, 0, 0, 0, 0, 0, 1 },
    // { 1, 0, 0, 0, 0, 0, 1 },
    // { 1, 1, 1, 1, 1, 1, 1 } });
    // System.out.println(ans4);

    // }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int M = sc.nextInt();
        int[][] arr = new int[N][M];
        for (int i = 0; i < N; i++) {
            String line = sc.next();
            for (int j = 0; j < M; j++) {
                arr[i][j] = line.charAt(j) - '0';
            }
        }
        int ans = solve(N, M, arr);
        System.out.println(ans);
    }

    private static int solve(int N, int M, int[][] arr) {
        Queue<Pass> queue = new LinkedList<>();
        boolean[][] visited = new boolean[N][M];
        int[] di = { 0, 1, 0, -1 };
        int[] dj = { 1, 0, -1, 0 };

        queue.add(new Pass(0, 0, 1));
        visited[0][0] = true;

        while (!queue.isEmpty()) {
            Pass now = queue.poll();
            if (now.i == (N - 1) && now.j == (M - 1)) {
                return now.cnt;
            }
            for (int i = 0; i < 4; i++) {
                int ni = now.i + di[i];
                int nj = now.j + dj[i];
                if (ni >= 0 && nj >= 0 && ni < N && nj < M
                        && !visited[ni][nj] && arr[ni][nj] == 1) {
                    visited[ni][nj] = true;
                    queue.add(new Pass(ni, nj, now.cnt + 1));
                }

            }
        }
        return -1;
    }

    static class Pass {
        int i;
        int j;
        int cnt;

        public Pass(int i, int j, int cnt) {
            this.i = i;
            this.j = j;
            this.cnt = cnt;
        }
    }
}

```
